# 3. 인덱스 튜닝

## 3.1 테이블 인덱스 최소화

테이블 랜덤 액서스를 최소화하는 것은 SQL 성능 최적화에 중요하다.


### 3.1.1 테이블 랜덤 액서스 최소화

#### ROWID

ROWID는 인덱스 스캔시 테이블 레코드를 찾아가기 위한 주소값이다.

ROWID는 테이블 레코드를 찾아가기 위한 논리적 주소 정보를 담고 있다.

-> C언어의 포인터와는 전혀 다른 개념이다.
-> 인덱스로 테이블 블록 액서스 시 ROWID를 분해하여 DBA 정보를 얻어야 한다.
-> ROWID가 가리키는 테이블블록을 버퍼캐시에서 먼저 찾고 없으면 디스크에서 블록을 읽어온다.

ROWID를 활용하는 과정은 생각보다 고비용이다.

### 3.1.2 인덱스 클러스터링 팩터

클러스터링 팩터(CF) : 군집성 계수, 특정 컬럼 기준으로 같은 값을 가진 데이터가 서로 모여있는 정도이다.

### 3.1.3 인덱스 손익분기점

인덱스 손익분기점 : 인덱스 Range Scan이 Table full scan 보다 느려지는 지점

**인덱스 액서스가 Table full scan보다 느려지는 요인**

1. 테이블 풀 스캔은 시퀀셜 액서스이나 인덱스 ROWID를 이용한 테이블 액서스는 랜덤 액서스이다.
2. 테이블 풀 스캔은 Multiblock I/O인 반면, 인덱스 ROWID를 이용한 테이블 액서스는 Single Block I/O이다.

위의 요인에 의해 인덱스 손익 분기점은 보통 5 ~ 20 % 의 낮은 수준에서 결정된다. 
- 단, CF 가 좋으면 90%까지도 상승한다.
- 테이블 크기가 아주 크면(1000만 건) 손익 분기점이 더 낮아진다.

### 3.1.4 인덱스 컬럼 추가

테이블 액서스를 최소화 하기 위한 방법 중 하나로 인덱스에 컬럼을 추가하는 방법이다.

EMP 테이블에서 현재 PK 이외의 [DEPTNO + JOB] 순으로 구성한 인덱스가 있는 상태로 아래와 같이 SQL을 작성한다 가정해보다

```sql
select /*+ index(emp emp_x01)*/ *
from emp
where deptno = 30
and sal >= 2000
```

위의 경우, sal 칼럼에 대한 인덱스가 존재하지 않아 아래 사진과 같이 6번의 액서스가 필요해진다.

![]('../홍성주/image/인덱스컬럼추가.jpg')

그러나 인덱스에 sal 칼럼을 추가하면 랜덤 액서스 횟수를 줄여줄 수 있다.

![]('../홍성주/image/인덱스컬럼추가2.jpg')

그러나 위의 경우 인덱스 관리 비용이 증가하고, DML 부하에 따른 트랜잭션 성능 저하가 발생할 수 있다.

### 3.1.5 인덱스만 읽고 처리

쿼리에 사용될 모든 칼럼을 인덱스에 추가하여 테이블 액서스를 발생하지 않게 하는 방법이다. 

테이블 랜덤 액서스를 줄일 수 있으나 추가해야 할 컬럼이 많아진다.

#### Include 인덱스

SQL Server 2005에 나온 기능으로 인덱스 키 이외에 미리 지정한 칼럼을 리프 레벨에 함께 저장하는 기능이다.

```create
create index emp_x01 on emp (deptno) include (sal)
```

위의 경우 일반적인 인덱스 칼럼 추가와 달리 sal 칼럼을 리프 블록에만 저장한다. 즉, 수평적 탐색에만 sal 조건을 필터 조건을 넣을 수 있다.

이로 인해 테이블 랜덤 액서스의 양을 줄일 수 있다. (단, 인덱스 스캔량은 인덱스 적용 안 했을떄와 동일)


### 3.1.6 인덱스 구조 테이블(IOT)

랜덤 액서스가 발생하지 않도록 테이블을 인덱스 구조로 생성하는 방식이다.

테이블을 찾아가기 위한 ROWID를 갖는 일반 인덱스와 달리 그 자리에서 테이블 데이터를 갖는다. 

일반적인 테이블(힙 테이블) 과 달리 정렬 상태를 유지하며 데이터를 입력한다. 

데이터가 정렬된 상태로 모여있어 Between, 부등호 조건으로 넓은 범위를 읽을 때 유리하다.


```
create table index_org_t (a number, b varchar(10), constraint index_org_t_pk primary key (a) )
organization index;
```

### 3.1.7 클러스터 테이블

클러스터 테이블에는 인덱스 클러스터와 해시 클러스터 두 가지가 존재한다.

#### 인덱스 클러스터 테이블

인덱스 클러스터 테이블은 클러스터 키 값이 같은 레코드를 한 블록에 모아서 저장하는 구조이다. 

![]('../홍성주/image/인덱스클러스터테이블.jpg')


인덱스 클러스터 테이블 생성 방법
```sql
-- 1. 클러스터 생성
create cluster c_dept# ( deptno number(2) ) index ;

-- 2. 클러스터 인덱스 정의
create index c_dept#_idx on cluster c_dept#;

-- 3. 클러스터 테이블 생성
create table dept (
    deptno number(2)    not null
    , dname varchar2(14)    not null
    , loc varchar2(13) )
cluster c_dept#( deptno );
```


클러스터 인덱스는 일반 B*Tree 구조를 사용하지만 테이블 레코드를 일일이 가지키지 않고, 해당 키 값을 저장하는 첫번째 데이터 블록을 가리킨다. 따라서 클러스터 인덱스 키 값은 항상 Unique 하다.

이로 인해 클러스터 인덱스를 스캔할 때 랜덤 액서스가 값 하나당 한번씩만 발생한다. 

#### 해시 클러스터 테이블

해시 알고리즘을 통해 클러스터를 찾아간다.

```sql
-- 1. 클러스터 생성
create cluster c_dept# ( deptno number(2) ) hashkeys 4 ;

-- 2. 클러스터 테이블 생성
create table dept (
    deptno number(2)    not null
    , dname varchar2(14)    not null
    , loc varchar2(13) )
cluster c_dept#( deptno );
```

## 3.2 부분 범위 처리
부분 범위 처리를 통해 인덱스 손익분기점의 한계를 극복할 수 있다.

### 3.2.1 부분 범위 처리

전체 쿼리 결과집합을 쉼없이 연속적으로 전송하지 않고 사용자로부터 Fetch Call이 있을때마다 일정량씩 나누어 전송하는 방법이다.

#### 정렬 조건이 있을 때 부분범위 처리

`select name from big_table order by created`

위와 같은 쿼리에서는 created 순으로 정렬을 해야 하기 때문에 부분범위 처리를 하기 힘들다.

만약 created 컬럼이 인덱스 선두에 위치하면 부분범위 처리가 가능하다.

#### Array Size 조정을 통한 Fetch Call 최소화

대량 데이터를 파일로 내려받는 경우 Array Size를 크게 하면 Fetch Call를 줄일 수 있다.

그러나 앞의 일부 데이터만 Fetch하다 멈추면 ArraySize를 작게 하는 것이 좋다.
