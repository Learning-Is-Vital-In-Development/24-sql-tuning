# 1장 SQL 처리 과정과 I/O
## SQL 파싱과 최적화

### 구조적, 집학적, 선언적 질의 언어

- SQL 은 `구조적 질의 언어` 라는 사전적 의미를 가지고 있음
- 원하는 결과집합을 구조적, 집합적으로 선언하지만, 그 결과집합을 만드는 과정은 절차적임
    - `사용자 SQL 작성 → 옵티마이저 실행계획 수립 → 프로시저`
    - 최종적인 프로시저를 옵티마이저가 만들어줌
- `옵티마이저 실행계획 수립 → 프로시저` 부터 프로시저를 실행 가능한 상태로 만드는 전 과정을 `SQL 최적화` 라고함

### SQL 최적화

- SQL 처리 과정은 아래와 같음
    - SQL 파싱
        - 파싱 트리 생성
        - Syntax 체크
        - Semantic 체크
    - SQL 최적화
        - 옵티마이저가 수행
    - 로우 소스 생성
        - 프로시저 형태로 포매팅

### SQL 옵티마이저

- 최적화 단계는 아래와 같음
    - 쿼리로 부터 후보군이 될 실행 계획을 찾음
    - 데이터 딕셔너리에 수집한 오브젝트 및 통계를 통해 실행계획의 예상비용 산정
    - 최저 비용의 실행계획 선택

![hello1](https://github.com/EunChanNam/24-sql-tuning/assets/75837025/5888dc20-f6d1-4659-bcbd-dc176b5ebc2a)


### 실행계획과 비용

- 인덱스를 사용하는지, 테이블 풀 스캔을 하는지 등 여러 데이터를 통해 cost 를 산정
- 산정한 cost 는 어디가지나 예상 비용이며 상황에 따라 달라질 수 있다
    - 실제 수행할 때, 발생하는 I/O 와 시간은 차이난다

### 옵티마이저 힌트

- 개발자가 옵티마이저에게 옵티마이저에게 실행계획을 수립할 때, 특정 부분에 대해서 강제성을 부여하는 것
- 쓸거면 잘써야한다
- 최적화 목표, 엑세스 방식, 조인 순서, 조인 방식, 병렬 처리 등 여러 힌트가 존재한다

## SQL 공유 및 재사용

- 동시성이 높은 온라인 트랜잭션 처리 시스템에서 `바인드 변수`는 매우 중요

### 소프트 파싱 vs 하드 파싱

<img width="334" alt="image" src="https://github.com/EunChanNam/24-sql-tuning/assets/75837025/f87e9e2e-21f3-49d6-a67f-51fe93ea4989">


- 프로시저를 재사용할 수 있도록 캐싱하는 메모리 공간을 `라이브러리 캐시` 라고함
    - SGA 의 구성요소중 하나
    - SGA 는 MySQL InnoDB 에 나오는 글로벌 영역인가?
- SQL 파싱 → 캐시에 존재 → 실행
    - 이 과정이 `소프트 파싱`
- SQL 파싱 → 캐시 미스 → 최적화 및 로우소스 생성 → 실행
    - 이 과정이 `하드 파싱`
    - 실행 과정을 수립하고 선택하는 과정은 굉장히 무거운 과정이며 CPU 를 많이 소비하는 작업
    - 그래서 하드 파싱
- 하드 파싱 작업이 굉장히 무겁기 때문에 라이브러리 캐시가 존재함

### 바인드 변수의 중요성

- 아래와 같은 경우를 보자
    - `SELECT * FROM CUSTOMER WHERE LOGIN_ID = ‘HELLO’`
    - `SELECT * FROM CUSTOMER WHERE LOGIN_ID = ‘GOOD’`
    - 위 두 쿼리는 서로 다른 쿼리다
    - 즉 첫번째 쿼리가 발생하고 두번째 쿼리가 발생할 때, 두번째 쿼리도 `하드파싱`이 수행된다
- 바인드 변수가 있다면?
    - `SELECT * FROM CUSTOMER WHERE LOGIN_ID = :1`
    - 이렇게 하나의 쿼리로 위 두 쿼리가 대응된다
    - 즉 `하드파싱`을 줄일 수 있다
- 대부분의 서비스에서 같은 상황에 있어서 쿼리의 바인드 변수 값만 바뀌고 쿼리의 구조 자체는 변하지 않기 때문에 리소스를 많이 절약할 수 있다

## 데이터 저장 구조 및 I/O 메커니즘

- I/O 튜닝이 곧 SQL 튜닝

### SQL 이 느린 이유

- SQL 은 디스크 I/O 를 유발하고 디스크 I/O 자체가 느리기 때문이다
- I/O 작업은 CPU 의 작업이 아니므로 I/O 작업이 발생하면 CPU 는 잠을 잔다
    - 물론 멀티프로세스, 멀티스레딩 환경에선 컨텍스트 스위칭을 통해 CPU 가 놀진 않는다
    - 하지만 컨텍스트 스위칭 자체도 리소스
    - 즉 느린건 그냥 디스크 I/O 자체가 느리기 때문이다

### 데이터베이스 저장 구조

<img width="282" alt="image" src="https://github.com/EunChanNam/24-sql-tuning/assets/75837025/2358294d-64c6-4181-8e3f-2294bd50edc6">


테이블스페이스 구조

- 테이블스페이스는 세그먼트를 담는 컨테이너로 여러개의 데이터파일(물리적 디스크 파일)로 구성된다
- 세그먼트
    - 테이블, 인덱스 같은 데이터 저장공간을 필요로 하는 오브젝트
    - 하나의 테이블 == 하나의 세그먼트, 하나의 인덱스 == 하나의 세그먼트
- 익스텐트
    - 테이블이나 인덱스의 공간을 확장하는 단위
    - 공간이 부족하면 테이블스페이스로 부터 추가적인 익스텐트를 할당받음
    - 하나의 익스텐트에는 하나의 테이블의 정보만 포함(블록도 마찬가지)
    - `연속`된 블록의 집합
    - 익스텐트끼리는 블록이 연속된 관계를 가지지 않음
- 블록
    - 실제로 데이터가 저장되는 공간
    - MySQL 에서는 `페이지` 라는 단위로 불림
    - 조회할 때, 블록 단위로 조회함
- 블록의 주소를 DBA 라고 부름
- 세그먼트 헤더에는 익스텐트 맵이 존재함
    - 각 익스텐트의 첫번째 블록의 DBA 를 담고있음. 이를 통해 접근 후 연속된 블록을 읽음

### 블록 단위 I/O

- DB 에서 데이터를 읽고 쓸 때, `블록 단위`로 읽고 씀
- 인덱스도 마찬가지로 블록단위로 읽고 씀
    - B-Tree 에서 하나의 노드가 하나의 블록

### 시퀀셜 액세스 vs 랜덤 액세스

- 테이블 혹은 인덱스 블록을 액세스하는 방식으로 시퀀셜, 랜덤 방식이 존재함

<img width="336" alt="image" src="https://github.com/EunChanNam/24-sql-tuning/assets/75837025/8d4b47bb-e807-4ebe-8bd3-fc793062d4bf">


- 시퀀셜
    - 논리적 혹은 물리적으로 연결된 순서에 따라 블록을 읽는 방식
    - 인덱스 B+Tree 에서 연결된 리프노드를 스캔하는 방식은 `시퀀셜`
- 랜덤
    - 특정 데이터 블록을 찾아가서 읽는 방식
    - 인덱스에서 리프노드에 저장된 주소를 통해 특정 데이터 블록을 읽는 방식은 `랜덤`
- 테이블의 데이터는 각각 데이터 블록이 논리적으로 연결돼있기 때문에 테이블 풀 스캔 방식을 할 때, `시퀀셜 액세스` 사용
    - 세그먼트 헤더 맵에서 읽어야될 익스텐트 목록과 각 익스텐트의 첫번째 DBA 를 얻어와서 스캔

### 논리적 I/O vs 물리적 I/O

- 라이브러리 캐시가 `코드캐시`라면 DB Buffer 캐시는 `데이터 캐시`다
- 조회한 데이터 블록을 버퍼 캐시에 저장하고 이후에 캐시된 블록에 접근할 때는 I/O 작업을 수행하지 않고 캐시에서 블록을 가져온다
- 논리적 I/O
    - **SQL 을 처리하는 과정에서 발생하는 총 블록 I/O**
    - `메모리 I/O + 물리적 I/O`
- 물리적 I/O
    - 디스크에서 발생한 총 블록 I/O
    - 디스크 I/O 기 때문에 겁나 느림
- 버퍼캐시 히트율이 높을수록 물리적 I/O 가 적음
- 히트율을 올려서 논리적 I/O 를 줄이는건 어렵지 않은 일이다
    - 하지만 논리적 I/O 를 통제하는 일은 굉장히 변수가 많다.
- **즉 논리적 I/O 는 통제가 힘들기 때문에 실직적으로 SQL 를 튜닝하기 위해서는 논리적 I/O 자체를 줄여야한다**
    - 근본적인 원인을 해결하는 느낌

### Single Block I/O vs Multiblock I/O

- Single Block I/O
    - 한 데이터 블록씩 요청해서 메모리에 적재하는 방식
    - 인덱스를 이용할 때, 특정 인덱스 블록으로 접근하거나 리프 인덱스 노드를 통해 특정 테이블 블록으로 접근할 때 사용
- Multiblock I/O
    - 여러 데이터 블록을 요청해서 메모리에 적재하는 방식
    - 테이블 풀 스캔을 할 때 사용
    - 한번에 요청하는 단위가 커야 I/O 자체가 줄어들어서 좋음
    - 요청하는 단위는 `인접한 블록`이기 때문에 익스텐트를 넘나들 수 는 없음
- Multiblock I/O 에서 Single Block I/O 의 발생
    - 찾는 블록에 대해서 물리적 I/O 가 필요할 때, 정해진 블록 요청단위가 충족되기 전까지 쌓아두고 요청을 미룬다
    - 쌓는 도중에 버퍼 캐시에 존재하는 블록 차례가 오면 쌓아둔 블록들을 물리적 I/O 로 먼저 읽는다
        - 그런데 쌓아둔게 하나다? 그러면 Single Block I/O 가 발생
    - 그냥 하나의 블록에 대한 물리적 I/O 요청이 필요하면 Single Block I/O 가 발생하는 것이다

### Table Full Scan vs Index Range Scan

- 인덱스를 사용한 스캔이 항상 옳은게 아니다
- Table Full Scan
    - `Multiblock I/O` + `시퀀셜 액세스`를 사용
    - 대량의 데이터를 검색할 때 좋음
- Index Range Scan
    - `Single Block I/O` + `랜덤 액세스`를 사용
    - 대량의 데이터 속에서 소량의 데이터를 검색할 때 좋음
- 두 경우에서 유리한 검색 상황의 특징을 보면 I/O 자체가 적다는 특징이 있다
    - 풀스캔일 땐, 많은 데이터에서 멀티 블록으로 I/O 작업 자체를 줄임
    - 인덱스일 땐, 스캔 대상이 되는 논리적 I/O 자체를 줄임
