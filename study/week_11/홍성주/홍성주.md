# SQL 옵티마이저

## 통계정보와 비용계산원리

### 선택도와 카디널리티

선택도 : 전체 레코드 중 조건절에 의해 선택되는 레코드 비율

```
선택도 = 1 / NDV(컬럼 값 종류 개수)
```

카디널리티 : 전체 레코드 중에서 조건절에 의해 선택되는 레코드 개수

```
카디널리티 = 총 Row 수 * 선택도 = 총 Row 수 / NDV
```

옵티마이저는 카디널리티를 구하고 그만큼의 데이터를 액서스하는데 드는 비용을 계산하여 테이블 액서스 방식, 조인 순서, 조인 방식들을 결정한다

### 통계정보

통계정보에는 오브젝트 통계와 시스템 통계가 있다.

오브젝트 통계는 다시 테이블 통계, 인덱스 통계, 컬럼 통계로 나누어진다. 

#### 테이블 통계

```sql
begin
    dbms_stats/gather_table_stats('scott', 'emp')
end;
```

#### 인덱스 통계

```sql
-- 인덱스 통계만 수집
begin
    dbms_stats.gather_index_stats ( ownname => 'scott', indname => 'emp_x01');
end;

-- 인덱스 통계를 수집하면서 인덱스 통계도 같이 수집
begin
    dbms_stats.gather_index_stats ('scott', 'emp', cascade=>true);
end;
```
#### 컬럼 통계

테이블 통계 수집될 때 같이 수집된다. 


#### 컬럼 히스토그램
= 조건에 대한 선택도는 1 / NUM_DISTINCT 공식으로 구하면 되나 데이터 분포도가 균일하지 않다면 위의 공식이 들어맞지 않는다. 이런 부정확한 정보는 최적이 아닌 실행계획으로 이어진다. 

이를 위해 옵티마이저는 통계 이외에도 히스토그램을 사용한다.

**히스토그램 유형**

* 도수분포 : 값별로 빈도수 저장
* 높이균형 : 각 버킷의 높이가 동일하도록 데이터 분포 관리
* 상위도수분포 : 많은 레코드를 가진 상위 n개 값에 대한 빈도수 저장
* 하이브리드 : 도수분포와 높이균형 히스토그램의 특성 결합

#### 시스템 통계

어플리케이션 및 하드웨어 성능 특성을 측정한 것이다. 

* CPU 속도
* 평균적 Single Block IO 속도
* 평균적 Multiblock IO 속도
* 평균적 Multiblock IO 개수
* IO 서브 시스템의 최대 처리량
* 병렬 Slave의 평균적인 처리량

### 비용계산 원리

인덱스 키값이 모두 = 조건으로 검색할 때
```
비용 = BLEVEL -- 인덱스 수직적 탐색비용
        + AVG_LEAF_BLOCKS_PER_KEY  -- 인덱스 수평적 탐색 비용
        + AVG_DATA_BLOCKS_PER_KEY -- 인덱스 테이블 랜덤 액서스 비용
```

인덱스 키값이 모두 = 조건이 아닌 경우

```
비용 = BLEVEL -- 인덱스 수직적 탐색비용
        + LEAF_BLOCKS * 유효 인덱스 선택도  -- 인덱스 수평적 탐색 비용
        + CLUSTERING_FACTOR * 유효 테이블 선택도 -- 인덱스 테이블 랜덤 액서스 비용
```

유효 인덱스 선택도, 유효 테이블 선택도는 컬럼 통계 및 히스토그램을 이용해 계산한다.

유효 인덱스 선택도란, 전체 인덱스 레코드 중 액서스 조건에 의해 선택될 것으로 예상되는 레코드 비중을 뜻한다. 

## 옵티마이저에 대한 이해

### 옵티마이저 종류

**CBO**

사용자 쿼리를 위해 후보군이 될 만한 실행계획들을 도출하고 데이터 딕셔너리에 미리 수집해 둔 통계정보를 이용해 각 실행계획의 예상 비용을 산정하고 그 중 가장 낮은 비용의 실행 계획 중 하나를 선택하는 옵티마이저

**RBO**

RBO는 데이터 특성을 나타내는 통계정보를 전혀 활용하지 않고 우선순위 규칙에 따라 실행계획을 만드는 옵티마이저다

요즘은 RBO를 거의 사용하지 않는다. 


### 옵티마이저 모드

* ALL_ROWS : 전체 처리속도 최적화
* FIRST_ROWS : 최초 응답속도 최적화
* FIRST_ROWS_N : 최초 N건 응답속도 최적화


ALL Rows 의 경우 옵티마이저는 쿼리 결과집합 전체를 읽는 전제로 시스템 리소스를 가장 적게 사용하는 실행계획을 선택한다.

First Rows는 옵티마이저 전체 결과 집합 중 앞쪽 일부만 읽다가 멈추는 것을 전제로 응답속도가 가장 빠른 실행계획을 선택한다. 현재는 쓰이지 않고 First Rows N으로 대체되었다.

First Rows End는 옵티마이저는 사용자가 앞쪽 N 로우만 읽고 멈추는 것을 전제로 응답속도가 가장 빠른 실행계획을 선택한다.

First Rows는 사용자가 얼마나 읽고 멈출지 지정을 안해놓아 비용 산정이 어렵다. 

### 옵티마이저에 영향을 주는 요소

* SQL 과 연산자 형태
* 인덱스, IOT, Cluster, partition, MV 등 옵티마이저 팩터
* 제약 설정
* 통계 정보
* 옵티마이저 힌트
* 옵티마이저 관련 파라미터

### 옵티마이저 한계

통계정보를 필요한 만큼 수집하는데 꽤나 많은 노력이 필요하다.

통계정보를 어느정도 수집해도 바인트 변수를 사용한 SQL에 히스토그램을 활용할 수 없다.

### 개발자의 역할

1. 필요한 최소 블록만 읽도록 쿼리 작성
2. 최적의 옵티마이저 팩터 제공
    * 전략적인 인덱스 구성
    * DBMS 가 제공하는 다양한 기능 활용
    * 옵티마이저 모드 설정
    * 정확하고 안정적인 통계 정보
3. 필요하면 힌트를 활용하여 최적의 액서스 경로 유도