# 7장. 옵티마이저

## 통계정보와 비용 계산 원리

### NVD, 선택도, 카디널리티  

만약 총 10만개 row, 상품 분류 컬럼에 '가전', '의류', '식음료', '생활용품' 네 개의 값이 있을때?  

    NDV(Number of Distinct Value) = 4  

    선택도 = 1/4  

    카디널리티 = 100000 * (1/4)  

CBO(Cost Based Optimizer, 비용 기반 옵티마이저) 에서 비용을 계산하는 출발점이 바로 선택도  


### 통계 정보

1. 오라클 테이블 통계

    - NUM_ROWS : 테이블에 저장된 총 레코드 갯수
    - BLOCKS :  
        테이블 블록수, 테이블에 할당된 총 블록수가 아닌 한번이라고 데이터가 입력된 적이 있는 익스텐트에 속한 총 블록수   
        테이블에 할당된 총 블록수는 dba_segments, user_segments 뷰에서 확인 해야 함.
    - AVG_ROW_LEN : 레코드당 평균 길이(Bytes)
    - SAMPLE_SIZE : 샘플링한 레코드 수
    - LAST_ANALIZED : 통계정보 수집 일시

    테이블 통계 수집

    ```SQL
    begin
        dbms_ststs.gather_table_stats('scott', 'emp')
    end
    ```

    테이블 통계 확인

    ```SQL
    SELECT num_rows, blocks, avg_row_len, sample_size, last_analyzed
    FROM all_tables
    WHERE owner = 'SCOTT'
    AND table_name = 'EMP';
    ```



2. 인덱스 통계

    BLEVEL:  
    - 브랜치 레벨의 약자. 인덱스 루트에서 리프 블록에 도달하기 직전까지 읽게 되는 블록 수. 인덱스 수직적 탐색 비용 계산에 사용

    LEAF_BLOCKS:  
    - 인덱스 리프 블록 총 개수.  인덱스 수평적 탐색 비용 계산에 사용

    NUM_ROWS:  
    - 인덱스에 저장된 레코드 개수.  인덱스 수평적 탐색 비용 계산에 사용

    DISTINCT_KEYS:  
    - 인덱스 키값의 조합으로 만들어지는 값의 종류 개수.  
    - 예를 들어, C1+C2로 구성한 인덱스에서 C1 컬럼에 3개, C2 컬럼에 4개 값이 있으면 최대 12개의 값의 종류가 만들어집니다. 실제 입력된 값의 종류 개수를 구해 놓은 수치. 인덱스 키값을 모두 '=' 조건으로 조회할 때의 선택도(Selectivity)  
    - 인덱스 수평적 탐색 비용 계산에 사용

    AVG_LEAF_BLOCKS_PER_KEY:  
    - 인덱스 키값을 모두 '=' 조건으로 조회할 때 읽게 될 리프 블록 개수.  

    AVG_DATA_BLOCKS_PER_KEY:  
    - 인덱스 키값을 모두 '=' 조건으로 조회할 때 읽게 될 테이블 블록 개수.  

    CLUSTERING_FACTOR:  
    - 인덱스 키값 기준으로 테이블 데이터가 모여 있는 정도.  
    - 인덱스 전체 레코드를 스캔하면서 테이블 레코드를 찾아갈 때 읽게 될 테이블 블록 개수를 미리 계산해 놓은 수치  
    테이블 액세스 비용 계산에 사용

3. 컬럼 통계

    컬럼통계는 테이블 통계를 수집하면서 함께 수집된다.

    NUM_DISTINCT:  
    - 컬럼 값의 종류 개수(NDV, Number of Distinct Values). 예를 들어, 성별 컬럼이면 2.

    DENSITY:  
    - '=' 조건으로 검색할 때의 선택도를 미리 구해 놓은 값. 히스토그램이 없거나, 있더라도 100% 균일한 분포를 갖는다면, 1 / NUM_DISTINCT 값과 일치.

    AVG_COL_LEN:  
    - 컬럼 평균 길이(Bytes).

    LOW_VALUE:  
    - 최소 값.

    HIGH_VALUE:  
    - 최대 값.

    NUM_NULLS:  
    - 값이 NULL인 레코드 수.

4. 컬럼 히스토그램

    데이터 분포가 균일하지 않은 컬럼의 경우 미리 구해놓은 DENSITY 값이 잘 들어맞지 않는 경우가 있다.  
    그래서 옵티마이저는 컬럼 히스토그램 정보를 함께 이용한다.

    도수분포 (FREQUENCY): 
    - 값별로 빈도수 저장.

    높이균형 (HEIGHT-BALANCED): 
    - 각 버킷의 높이가 동일하도록 데이터 분포 관리.

    상위도수분포 (TOP-FREQUENCY): 
    - 많은 레코드를 가진 상위 n개 값에 대한 빈도수 저장 (12c 이상).

    하이브리드 (HYBRID): 
    - 도수분포와 높이균형 히스토그램의 특성 결합 (12c 이상).

5. 시스템 통계
    
    어플리케이션 및 앱의 하드웨어 성능 특성을 측정한 정보
    CPU 속도, 평균적인 Single block I/O 정보 등



### CBO에서 COST 의 정확한 의미

예전 I/O 비용 모델 : 예상 I/O Call `횟수`  

최신 CPU 비용 모델 : 싱글 block I/O Call 기준의 `상대적 시간`
- Cost 100 = 싱글 block I/O Call 100번 하는 정도의 시간



## 옵티마이저의 종류

### RBO 
Rule Based Optimizer
정해진 규칙에 따라 cost 계산

- 단점 : 통계정보를 활용하지 않기 때문에 대량의 데이터 처리에 부적합
    
    ex 인덱스가 등급이 높고 풀스캔이 가장 낮은 등급 : 무조건 인덱스가 있으면 인덱스를 쓰는 등 한계가 존재


### CBO
Cost Based Optimizer  
비용기반 옵티마이저  
통계정보와 히스토그램 활용해서 실행계획 수립

### CBO의 옵티마이저 모드
옵티마이저 모드란 ?  
원하는 목표에 맞게 옵티마이저의 모드를 변경 할 수 있다.

- ALL_ROWS: 
    - 전체 처리속도 최적화
    - 전체 처리속도를 향상하기위해 CPU, 메모리 사용을 최소화 하는 방향으로 실행계획을 수립하게 됨
- FIRST_ROWS: 
    - 최초 응답속도 최적화
    - ALL_ROWS 대비 풀스캔 보단 인덱스, 해시조인 보단 NL 조인을 더 많이 사용
- FIRST_ROWS_N: 최초 N건 응답속도 최적화
    - 소트연산을 최소화 하는데에 특화
    - ORDER BY 컬럼에 인덱스가 있을 경우 인덱스를 사용하는 방향으로 실행계획 수립
    - FIRST_ROWS는 이제 사라지게 될 옵션 FIRST_ROWS_N 으로 대체 : 왜 ? 몇건 읽을지 모르는 상황에서 비용 측정, 실행계획을 수립하는데 한계가 있기 때문

### 옵티마이저에 영향을 미치는 요소

1. SQL 을 어떻게 작성했는지에 따라
    - 어떤 연산자 (BETWEEN ,= 조건, LIKE, IN 등)를 사용했는지에 따라 달라질 수 있다.
2. 인덱스, IOT, 클러스터, 파티션, MV 등 옵티마이징 팩터
    - 쿼리가 똑같아도 인덱스, IOT, 클러스터, 파티션, MV 등을 구성했는지의 여부에 따라 달라질 수 있다.
3. Constraint 설정 
    - PK, FK, Unique, Not Null 등의 제약조건에 따라 옵티마이저가 다른 결정 을 내릴 수 있다.
4. 통계정보
    - 잘 작동하던 쿼리가 느려졌다면 -> 통계정보가 원인 일 수 있다.
    
        - 특정 테이블의 통계정보를 갑자기 삭제 해버렸기 때문
        - 대량의 데이터를 지우고 다시 입력하려고 했는데 삭제된 상태로 통계정보가 작성되었기 때문
        - 3년간 갱신하지 않던 특정 테이블의 통계정보를 갑자기 갱신 했기 때문
        - 통계정보 없이 운용하던 테이블에 인덱스를 재생성 했기 때문 (오라클 10g 부터 인덱스를 생성하면 통계정보를 자동생성한다.)
        - 테이블이나 인덱스를 재생성하면서 파티션단위로만 통계정보를 수집한다. (?)

5. 옵티마이저 힌트
    - 옵티마이저에게 가장 영향을 크게 미치는 요소
    - 힌트를 잘 작성했는데도 실행계획이 바뀌지 않는다면 ?
        - 힌트 문법 잘못 작성, 잘못된 의미의 힌트 기술
        - 잘못된 참조, 논리적으로 불가능한 엑세스 경로
        - 버그

### 옵티마이저의 한계

- 인간의 실수 : 애초에 옵티마이저도 사람이 만든 소프트웨어 : 버전에 따라 같은 상황에서 다른 결정을 내리는 옵티마이저 = 지금 선택이 최선이 아닐 수 있다.
- 통계정보 수집및 관리에는 시간, 비용이 많이 든다.
- SQL 바인드변수 사용 : 컬럼 히스토그램 활용 애초에 못함

### 개발자의 역할

1. 필요한 최소 블록만 읽도록 쿼리 작성

```sql
SELECT *
FROM (
    SELECT ROWNUM NO, 등록일자, 번호, 제목,
           회원명, 게시판유형명, 질문유형명, 아이콘, 댓글개수
    FROM (
        SELECT A.등록일자, A.번호, A.제목, B.회원명, C.게시판유형명, D.질문유형명,
               GET_ICON(D.질문유형코드) 아이콘,
               (SELECT ... FROM ...) 댓글개수
        FROM 게시판 A
        JOIN 회원 B ON B.회원번호 = A.작성자번호
        JOIN 게시판유형 C ON C.게시판유형 = A.게시판유형
        JOIN 질문유형 D ON D.질문유형 = A.질문유형
        WHERE A.게시판유형 = :TYPE
        ORDER BY A.등록일자 DESC, A.질문유형, A.번호
    )
    WHERE ROWNUM <= (:page * 10)
)
WHERE NO >= (:page - 1) * 10 + 1;

```

서브쿼리로 얻은 10건의 데이터에 대해서만 아이콘, 댓글개수 계산

```sql
SELECT /*+ ORDERED USE_NL(B) USE_NL(C) USE_NL(D) */
       A.등록일자, A.번호, A.제목, B.회원명, C.게시판유형명, D.질문유형명,
       GET_ICON(D.질문유형코드) 아이콘,
       (SELECT ... FROM ...) 댓글개수
FROM (
    SELECT A.*, ROWNUM NO
    FROM (
        SELECT 등록일자, 번호, 제목, 작성자번호, 게시판유형명, 질문유형명
        FROM 게시판
        WHERE 게시판유형 = :TYPE
          AND 작성자번호 IS NOT NULL
          AND 게시판유형 IS NOT NULL
          AND 질문유형 IS NOT NULL
        ORDER BY 등록일자 DESC, 질문유형, 번호
    ) A
    WHERE ROWNUM <= (:page * 10)
) A
JOIN 회원 B ON A.작성자번호 = B.회원번호
JOIN 게시판유형 C ON A.게시판유형 = C.게시판유형
JOIN 질문유형 D ON A.질문유형 = D.질문유형
WHERE A.NO >= (:page - 1) * 10 + 1
ORDER BY A.등록일자 DESC, A.질문유형, A.번호;
```

2. 전략적인 인덱스 구성

3. DBMS가 제공하는 다양한 기능 사용 
- 파티셔닝, 클러스터링, IOT, Result Cache 등 적극 활용

4. 통계정보, 옵티마이저 모드 신경쓰기

5. 옵티마이저가 제대로 실행계획 수립 못할때 힌트를 적절히 주는 것도 중요