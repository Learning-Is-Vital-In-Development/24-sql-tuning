# 2장 인덱스 기본
## 인덱스 구조 및 탐색

- 데이터 탐색은 `풀스캔` `인덱스 스캔` 으로 나뉜다

### 인덱스 튜닝의 두 가지 핵심요소

- 인덱스 스캔 효율화 튜닝
    - 인덱스를 얼마나 잘 활용하는지
    - 인덱스를 통해 스캔하는 row 수 자체를 줄이며 튜닝하는 것
- 랜덤 액세스 최소화 튜닝
    - 테이블 액세스 자체를 줄이며 튜닝하는 것
- 두 가지는 결국 비슷한 의미라고 생각함
    - 스캔하는 인덱스 row 수가 줄어들면 자연스럽게 테이블 엑세스 자체도 줄어들기 때문이다
    - 물론 커버링 인덱스 같은 예외도 존재
- **튜닝의 핵심은 랜덤 I/O 자체를 줄이는 것이다**

### 인덱스의 구조

- B* Tree 구조
    - 루트 노드 : 인덱스의 시작노드(한개의 키만 존재)
    - 브랜치 노드
        - 리프 노드와 루트 노드 사이의 노드
        - 각 키는 자식 노드를 가지며 작은 키들을 가진 노드와 큰 키들을 가진 노드로 구성(정렬된 상태)
    - 리프 노드
        - 제일 하단 노드로 `ROWID` 를 가지고 있음
        - 리프 노드끼리는 양방향 연결리스트로 연결돼있음
- 각 노드에는 인덱스 컬럼으로 구성된 키 값들이 있으며 정렬돼있다
- `ROWID` : 데이터 블록 주소(DBA) + 로우 번호

### 인덱스 수직적 탐색

- 인덱스 레코드 중 조건을 만족하는 첫 번째 레코드를 찾는 과정
    - 인덱스 스캔의 시작지점을 찾는 과정
- 정렬된 키들을 이용해서 탐색하므로 logN 의 시간 복잡도를 가짐

### 인덱스 수평적 탐색

- 인덱스 수직적 탐색으로 인덱스 스캔의 시작지점을 찾고나서 리프 노드를 스캔하는 과정
- 양방향으로 연결돼있기 때문에 좌 → 우, 우 → 좌 방향으로 탐색가능
- 수평적 탐색으로 얻은 ROWID 를 통해 테이블 액세스를 하거나 커버링 인덱스인 경우 바로 해결함

### 결합 인덱스 구조와 탐색

- 두개 이상의 컬럼을 결합해서 만든 인덱스
- 복합컬럼인덱스 라고도 함
- 정렬 구조
    - index(a) 이런 경우에 데이터가 a 를 기준으로 정렬돼있다면
    - index(a, b) 이런 경우에는 데이터가 a 를 기준으로 정렬돼있고, a 가 같은 경우에 b 를 기준으로 정렬돼있다
    - 즉 정렬 기준이 a, b 인 것이다
- 조건문이 모두 `“=”` 라면 인덱스의 컬럼 순서는 중요하지 않다
- 갑자기 궁금한건데 index(a, b) 이렇게 있을때 `where a < 100 and b < 100` 이렇게 두조건 모두 range 로 걸면 인덱스 리프노드를 ——> | | | ——>  | | | ——> 이렇게 드문드문 읽는건가?

## 인덱스 기본 사용법

- 기본 사용법은 `Range Scan` 을 이용하는 방법이다

### 인덱스를 사용한다는 것

- `수직 탐색 → 수평 탐색 → 테이블 액세스` 과정으로 이루어짐
- 인덱스를 정상적으로 이용한다는 것은
    - 스캔 시작점을 찾아 스캔하다 중간에 멈추는 것을 의미한다

### 인덱스를 Range Scan 할 수 없는 이유

- `인덱스 컬럼을 가공할 때`
    - Range Scan 을 하지 못하는 이유는 `인덱스 스캔의 시작점을 찾을 수 없기 때문`이다
    - ex
        - `where substr(생년월일, 5, 2) = ‘05’`
        - `where nvl(주문수량, 0) < 100`
        - `where 업체명 like ‘%대한%’`
            - like 문은 문자열 제일 앞에 % 가 들어오면 인덱스를 사용 못함
- OR 절을 사용하면 인덱스를 타지 못한다
    - 하지만 use_concat 힌트를 사용해서 OR Expansion 을 이용하면 가능하다
    - ex) `where (전화번호 = :tel_no OR 고객명 = :cust_name)` 해당 쿼리가
        - `where 전화번호 = :tel union all where 고객명 = :cust_name` 이렇게 바뀐다
- IN 절도 마찬가지로 인덱스를 타지 못한다
    - 여기도 비슷하게 여러개의 `“=”` 으로 쪼개서 `union all` 하는 쿼리로 변환해서 사용한다

### 더 중요한 인덱스 사용 조건

- 인덱스는 인덱스의 컬럼 순서로 정렬을 한다
    - 즉 조건문에 인덱스의 선두 컬럼이 없다면 인덱스를 사용할 수 없다
        - **정확히는 Index Range Scan 을 활용할 수 없다**
    - index(a, b, c) 가 있을 때, 조건문에 b, c 만 있어도 안되고 a, c 이렇게 있어도 안됨
- 컬럼을 가공해도 컬럼의 앞부분만 멀쩡히 존재한다면 인덱스 활용 가능
- 인덱스를 타는거 자체는 쉽다
    - 그냥 선행 컬럼이 조건문에 존재하기만 하면 인덱스를 탈 수 있다
    - **하지만 인덱스를 타기만 한다고 좋은 성능은 아니다.** **`인덱스를 잘 효율적으로 타야한다`**
- 인덱스를 잘타는지는 리프 노드에서 스캔하는 양을 봐야한다

### 인덱스를 이용한 소트 연산 생략

- 인덱스의 가장 중요한 특징은 데이터가 인덱스 키를 기준으로 `정렬` 되어있다는 점이다
- 아래 쿼리가 대표적인 예다
    - index(a)
    - `where a between 1 and 100 order by a asc`
- 소트 연산을 인덱스로 생략하지 못하면 실행 계획에 `SORT (ORDER BY)` 이렇게 기록된다
- 인덱스 리프 노드는 양방향으로 연결돼있기 때문에 `asc` 가 아니라 `desc` 인 경우에는 인덱스를 역순으로 읽으면서 소트 연산을 생략할 수 있다

### ORDER BY 절에서 컬럼 가공

- `ORDER  BY` 도 당연히 가공된 컬럼을 사용하면 인덱스를 사용하지 못한다
- 아래같은 억까 상황을 조심하자
    - `SELECT TO_CHAR(A.주문번호) as 주문번호 … ORDER BY 주문번호`
    - 이 경우에 주문번호는 `as 주문번호`를 따라가서 `TO_CHAR` 함수가 적용된 가공된 컬럼을 사용하게 돼서 소트 연산을 생략하지 못한다.
    - `ORDER BY A.주문번호` 이렇게 명시해서 해결 가능

### SELECT-LIST 에서 컬럼 가공

- `MIN`, `MAX` 함수들에 대해서도 인덱스가 있다면 정렬 작업을 생략하고 하나의 레코드만 읽어서 처리할 수 있다
    - 만약 `index(a, b)` / `SELECT MAX(b) from TABLE where a > 100`
    - 이렇게 range 로 존재한다면 인덱스 못탐. “=” 이어야함

### 자동 형변환

- 편리하지만 묵시적으로 데이터 타입을 변형시키켜서 가공하는 역할을 하기 때문에 인덱스를 못타는 경우가 있으니까 조심하자
- 차라리 명시적으로 사용하자

## 인덱스 확장기능 사용법

### Index Range Scan

![image](https://github.com/EunChanNam/24-sql-tuning/assets/75837025/82550cd1-17a6-4a4c-ac64-fc1f4c5c8b03)


- 가장 일반적인 사용법
- 인덱스 루트노드에서 리프노드까지 `수직탐색` 후 필요한 범위만 `수평탐색`

### Index Full Scan

![image](https://github.com/EunChanNam/24-sql-tuning/assets/75837025/7eef46be-3b1e-48a2-b75d-70d814ef83d7)


- 수직탐색 없이 바로 리프노드를 처음부터 끝까지 풀 스캔
- Index Full Scan 이 활용되는 경우는 아래와 같다
    - 검색 결과가 전체중 극히 일부인 경우 → 데이터 크기 자체가 인덱스가 테이블보다 슬림하기 때문에
    - 조건문에 대한 컬럼이 존재는 하는데 순서가 안맞음 + 커버링 인덱스
- Index Full Scan 은 소트연산 생략에도 활용된다
    - 근데 소트연산을 생략하겠다고 조건문에서 활용하지도 못하는 인덱스를 억지로 활용하려다가 오히려 성능이 안좋아 질 수 있다

### Index Unique Scan

- 수직 탐색만으로 데이터를 스캔하는 방식 (수평 탐색을 안함)
- 유니크 인덱스에 `“=”` 조건만 존재할때 발생
- 유니크 인덱스가 결합인덱스 일때 ex) (a, b, c)
    - `a = ? and b = ?`  로 검색하면 range 스캔 발생
    - (a, b, c) 조합이 유니크한 인덱스이기 때문이다

### Index Skip Scan

![image](https://github.com/EunChanNam/24-sql-tuning/assets/75837025/60b87ca7-b10f-42a1-a493-ecb9fdda53e9)


- 인덱스 선두 컬럼이 조건문에 없어도 활용 가능한 스캔 방식
- 스킵 스캔의 **아주 중요한 조건**
    - 없는 선두 컬럼의 유니크한 값이 적을 것
    - 후행 컬럼의 유니크한 값이 많을 것
- 위 조건이 나온 이유는 스킵스캔의 동작 방식을 이해하면 이해된다
    - index(gender, age)
    - `select * from age < 26` 이렇게 생긴 쿼리가 아래처럼 작동한다
        - `select * from gender = ‘MAN’ and age < 26`
        - `select * from gender = ‘WOMAN’ and age < 26`
    - 이런식으로 선행컬럼 조건이 있는 것처럼 여러번 스캔하는 방식으로 동작한다
    - 때문에 없는 선행컬럼이 유니크한 값이 적어야하고 후행컬럼은 유니크한 값이 많아야한다
- 쉽게 설명하기 위해 쿼리가 두개로 나뉜 것처럼 설명했지만 정확한 동작방식은 아래와 같다
    - 리프 블록을 읽으면서 해당 블록에 조건에 만족하는 데이터가 있을 가능성이 있는 블록만 읽고 아닌 블록은 스킵한다.
    - 선행 컬럼을 기준으로 후행 컬럼은 정렬돼있기 때문에 가능성을 판단하기에 용이하다

### Index Fast Full Scan

- 인덱스를 논리적인 구조대로 읽지않고 물리적인 구조대로 스캔한다
- 기존의 `Single Block I/O` 방식으로 읽지않고 `Multi Block I/O` 방식으로 스캔한다
    - 풀 스캔 기준 당연히 Multi Block I/O 가 더 빠름
- 논리적 구조대로 읽지않기 때문에 정렬을 보장하지 않는다
- 병렬 스캔이 가능하다
    - `Direct Path I/O` 를 사용한다는데 지금은 뭔지 모르겠다(뒤에 나온다고함)
    - 병렬 스캔… 궁금하다
- 커버링 인덱스여야 사용가능하다는 조건이 있음 (당연한 얘기인듯!)

### Index Range Scan Descending

- 앞서 인덱스 리프 블록은 양방향으로 연결돼있다고 했는데, 때문에 인덱스를 역방향으로 스캔이 가능하다
    - `DESC` 정렬 조건에도 사용가능하고 `MIN`, `MAX` 함수에서도 사용가능하다
